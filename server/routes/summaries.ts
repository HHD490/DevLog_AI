import { Router } from 'express';
import { db, schema } from '../db';
import { eq, desc } from 'drizzle-orm';
import { geminiService } from '../services/geminiService';

const router = Router();

// GET /api/summaries - Get all daily summaries
router.get('/', async (req, res) => {
    try {
        const summaries = await db.select()
            .from(schema.dailySummaries)
            .orderBy(desc(schema.dailySummaries.date));

        // Transform to object keyed by date (frontend format)
        const result: Record<string, any> = {};
        for (const summary of summaries) {
            result[summary.date] = {
                date: summary.date,
                content: summary.content,
                keyAchievements: JSON.parse(summary.keyAchievementsJson || '[]'),
                techStackUsed: JSON.parse(summary.techStackJson || '[]'),
                autoGenerated: summary.autoGenerated
            };
        }

        res.json(result);
    } catch (error) {
        console.error('Error fetching summaries:', error);
        res.status(500).json({ error: 'Failed to fetch summaries' });
    }
});

// POST /api/summaries/:date/generate - Generate summary for a specific date
router.post('/:date/generate', async (req, res) => {
    try {
        const { date } = req.params;

        // Parse date as local timezone (YYYY-MM-DD format)
        // Create date range for the specified day in local time
        const [year, month, day] = date.split('-').map(Number);
        const dateStart = new Date(year, month - 1, day, 0, 0, 0, 0);
        const dateEnd = new Date(year, month - 1, day, 23, 59, 59, 999);

        console.log(`[Summaries] Generating recap for ${date}, range: ${dateStart.toISOString()} to ${dateEnd.toISOString()}`);

        // Get all logs and filter by date (comparing in local time)
        const allLogs = await db.select().from(schema.logs);
        const dateLogs = allLogs.filter(log => {
            const logDate = new Date(log.timestamp);
            return logDate >= dateStart && logDate <= dateEnd;
        });

        console.log(`[Summaries] Found ${dateLogs.length} logs for ${date}`);

        if (dateLogs.length === 0) {
            return res.status(404).json({ error: 'No logs found for this date' });
        }

        // Generate summary using AI
        const summary = await geminiService.generateDailySummary(
            date,
            dateLogs.map(l => ({ timestamp: l.timestamp, content: l.content, source: l.source }))
        );

        // Check if summary exists
        const existing = await db.select()
            .from(schema.dailySummaries)
            .where(eq(schema.dailySummaries.date, date));

        if (existing.length > 0) {
            // Update
            await db.update(schema.dailySummaries)
                .set({
                    content: summary.content,
                    keyAchievementsJson: JSON.stringify(summary.keyAchievements),
                    techStackJson: JSON.stringify(summary.techStackUsed),
                    autoGenerated: false, // Manual generation
                    processedForSkillTree: false
                })
                .where(eq(schema.dailySummaries.date, date));
        } else {
            // Insert
            await db.insert(schema.dailySummaries).values({
                date,
                content: summary.content,
                keyAchievementsJson: JSON.stringify(summary.keyAchievements),
                techStackJson: JSON.stringify(summary.techStackUsed),
                autoGenerated: false,
                processedForSkillTree: false
            });
        }

        res.json({
            date: summary.date,
            content: summary.content,
            keyAchievements: summary.keyAchievements,
            techStackUsed: summary.techStackUsed
        });
    } catch (error) {
        console.error('Error generating summary:', error);
        res.status(500).json({ error: 'Failed to generate summary' });
    }
});

// POST /api/summaries/migrate - Migrate summaries from localStorage
router.post('/migrate', async (req, res) => {
    try {
        const { summaries } = req.body;

        if (typeof summaries !== 'object') {
            return res.status(400).json({ error: 'Summaries object is required' });
        }

        let migrated = 0;

        for (const [date, summary] of Object.entries(summaries)) {
            const s = summary as any;

            const existing = await db.select()
                .from(schema.dailySummaries)
                .where(eq(schema.dailySummaries.date, date));

            if (existing.length === 0) {
                await db.insert(schema.dailySummaries).values({
                    date,
                    content: s.content || '',
                    keyAchievementsJson: JSON.stringify(s.keyAchievements || []),
                    techStackJson: JSON.stringify(s.techStackUsed || []),
                    autoGenerated: false,
                    processedForSkillTree: false
                });
                migrated++;
            }
        }

        res.json({ success: true, migrated });
    } catch (error) {
        console.error('Error migrating summaries:', error);
        res.status(500).json({ error: 'Failed to migrate summaries' });
    }
});

export default router;
