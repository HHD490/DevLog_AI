/**
 * Scheduler Service
 * Handles scheduled tasks like daily recaps
 * AI calls proxied to Python backend
 */

import cron from 'node-cron';
import { db, schema } from '../db';
import { eq, and, gte, lte, sql } from 'drizzle-orm';
import { batchProcessPendingEntries } from './tagService';
import { syncGitHubToLogs } from '../routes/github';
import { processUnprocessedLogs, checkEmbeddingServiceHealth } from './embeddingService';

const PYTHON_BACKEND_URL = process.env.PYTHON_BACKEND_URL || 'http://localhost:5001';

/**
 * Initialize all scheduled tasks
 */
export function initScheduler(): void {
    console.log('[Scheduler] Initializing scheduled tasks...');

    // Daily recap at 23:45 every day (Asia/Shanghai timezone)
    cron.schedule('45 23 * * *', async () => {
        console.log('[Scheduler] Running daily recap generation...');
        await generateDailyRecapIfNeeded();
    }, {
        timezone: 'Asia/Shanghai'
    });

    // Batch process pending AI entries every 10 minutes
    cron.schedule('*/10 * * * *', async () => {
        console.log('[Scheduler] Running batch AI processing...');
        try {
            const result = await batchProcessPendingEntries();
            if (result.processed > 0) {
                console.log(`[Scheduler] Batch processed ${result.processed} entries`);
            }
        } catch (error) {
            console.error('[Scheduler] Batch processing error:', error);
        }

        // Also process unprocessed embeddings
        try {
            const health = await checkEmbeddingServiceHealth();
            if (health && health.status === 'ok') {
                const processed = await processUnprocessedLogs();
                if (processed > 0) {
                    console.log(`[Scheduler] Embedding processed ${processed} logs`);
                }
            }
        } catch (error) {
            console.error('[Scheduler] Embedding processing error:', error);
        }
    });

    // GitHub sync at 23:43 every day, before daily recap
    cron.schedule('43 23 * * *', async () => {
        console.log('[Scheduler] Running pre-recap GitHub sync...');
        try {
            const result = await syncGitHubToLogs();
            if (result.synced > 0) {
                console.log(`[Scheduler] GitHub sync: ${result.synced} new items synced`);
            } else {
                console.log(`[Scheduler] GitHub sync: no new items`);
            }
        } catch (error) {
            console.error('[Scheduler] GitHub sync error:', error);
        }
    }, {
        timezone: 'Asia/Shanghai'
    });

    console.log('[Scheduler] Scheduled tasks initialized:');
    console.log('  - GitHub sync: 23:43 (Asia/Shanghai)');
    console.log('  - Daily recap: 23:45 (Asia/Shanghai)');
    console.log('  - Batch AI processing: every 10 minutes');
    console.log('  - Embedding processing: every 10 minutes');
}

/**
 * Generate daily recap if:
 * 1. There are logs for today
 * 2. No manual recap exists for today (auto-generated ones can be overwritten)
 */
async function generateDailyRecapIfNeeded(): Promise<void> {
    const today = new Date();
    const todayStr = formatDate(today);

    // Get start and end of today in timestamp
    const startOfDay = new Date(today);
    startOfDay.setHours(0, 0, 0, 0);
    const endOfDay = new Date(today);
    endOfDay.setHours(23, 59, 59, 999);

    // Check for today's logs
    const todayLogs = await db.select()
        .from(schema.logs)
        .where(and(
            gte(schema.logs.timestamp, startOfDay.getTime()),
            lte(schema.logs.timestamp, endOfDay.getTime())
        ));

    if (todayLogs.length === 0) {
        console.log('[Scheduler] No logs today, skipping recap generation');
        return;
    }

    // Check if manual recap exists
    const existingRecap = await db.select()
        .from(schema.dailySummaries)
        .where(eq(schema.dailySummaries.date, todayStr));

    if (existingRecap.length > 0 && !existingRecap[0].autoGenerated) {
        console.log('[Scheduler] Manual recap already exists, skipping');
        return;
    }

    // Generate recap via Python backend
    try {
        const response = await fetch(`${PYTHON_BACKEND_URL}/ai/summary`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                date: todayStr,
                logs: todayLogs.map(l => ({
                    timestamp: l.timestamp,
                    content: l.content,
                    source: l.source
                }))
            })
        });

        if (!response.ok) {
            const error = await response.text();
            console.error('[Scheduler] Python backend error:', error);
            throw new Error('Failed to generate summary');
        }

        const summary = await response.json();

        // Upsert the summary
        if (existingRecap.length > 0) {
            await db.update(schema.dailySummaries)
                .set({
                    content: summary.content,
                    keyAchievementsJson: JSON.stringify(summary.key_achievements),
                    techStackJson: JSON.stringify(summary.tech_stack_used),
                    autoGenerated: true
                })
                .where(eq(schema.dailySummaries.date, todayStr));
        } else {
            await db.insert(schema.dailySummaries).values({
                date: todayStr,
                content: summary.content,
                keyAchievementsJson: JSON.stringify(summary.key_achievements),
                techStackJson: JSON.stringify(summary.tech_stack_used),
                autoGenerated: true,
                processedForSkillTree: false
            });
        }

        console.log(`[Scheduler] Daily recap generated for ${todayStr}`);
    } catch (error) {
        console.error('[Scheduler] Failed to generate daily recap:', error);
    }
}

/**
 * Manual trigger for daily recap (for testing or manual runs)
 */
export async function triggerDailyRecap(dateStr?: string): Promise<{
    success: boolean;
    message: string;
}> {
    const targetDate = dateStr || formatDate(new Date());

    // Parse date to get timestamp range
    const date = new Date(targetDate);
    const startOfDay = new Date(date);
    startOfDay.setHours(0, 0, 0, 0);
    const endOfDay = new Date(date);
    endOfDay.setHours(23, 59, 59, 999);

    // Get logs for the date
    const logs = await db.select()
        .from(schema.logs)
        .where(and(
            gte(schema.logs.timestamp, startOfDay.getTime()),
            lte(schema.logs.timestamp, endOfDay.getTime())
        ));

    if (logs.length === 0) {
        return {
            success: false,
            message: `No logs found for ${targetDate}`
        };
    }

    try {
        const response = await fetch(`${PYTHON_BACKEND_URL}/ai/summary`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                date: targetDate,
                logs: logs.map(l => ({ timestamp: l.timestamp, content: l.content }))
            })
        });

        if (!response.ok) {
            const error = await response.text();
            throw new Error(error);
        }

        const summary = await response.json();

        // Check if exists
        const existing = await db.select()
            .from(schema.dailySummaries)
            .where(eq(schema.dailySummaries.date, targetDate));

        if (existing.length > 0) {
            await db.update(schema.dailySummaries)
                .set({
                    content: summary.content,
                    keyAchievementsJson: JSON.stringify(summary.key_achievements),
                    techStackJson: JSON.stringify(summary.tech_stack_used),
                    autoGenerated: false // Manual trigger = not auto
                })
                .where(eq(schema.dailySummaries.date, targetDate));
        } else {
            await db.insert(schema.dailySummaries).values({
                date: targetDate,
                content: summary.content,
                keyAchievementsJson: JSON.stringify(summary.key_achievements),
                techStackJson: JSON.stringify(summary.tech_stack_used),
                autoGenerated: false,
                processedForSkillTree: false
            });
        }

        return {
            success: true,
            message: `Daily recap generated for ${targetDate}`
        };
    } catch (error) {
        console.error('[Scheduler] triggerDailyRecap error:', error);
        return {
            success: false,
            message: `Failed to generate recap: ${error}`
        };
    }
}

function formatDate(date: Date): string {
    return date.toISOString().split('T')[0];
}
